package project

import (
	"fmt"
	"os"
	"path/filepath"
)

func InitProject(lang, name, targetDir string, gitInit bool) error {
	fmt.Printf("Initializing %q project (%s) in %s\n", name, lang, targetDir)

	if err := ensureTargetDirAvailable(targetDir); err != nil {
		return err
	}

	switch lang {
	case "go":
		if err := initGoProject(name, targetDir); err != nil {
			return err
		}
	case "node", "js":
		if err := initNodeProject(name, targetDir, false); err != nil {
			return err
		}
	case "ts":
		if err := initNodeProject(name, targetDir, true); err != nil {
			return err
		}
	case "empty", "none":
		if err := initEmptyProject(name, targetDir); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported lang: %s (expected: go, node, ts, vue, empty)", lang)
	}

	if gitInit {
		if err := initGitRepo(targetDir); err != nil {
			return fmt.Errorf("project initialized, but git init failed: %w", err)
		}
	}

	fmt.Println("Project initialized.")
	return nil
}

func initGoProject(name, targetDir string) error {
	if targetDir != "." {
		if err := os.MkdirAll(targetDir, 0o755); err != nil {
			return err
		}
	}

	dirs := []string{
		filepath.Join(targetDir, "cmd", name),
		filepath.Join(targetDir, "internal"),
		filepath.Join(targetDir, "pkg"),
		filepath.Join(targetDir, "config"),
	}
	for _, d := range dirs {
		if err := os.MkdirAll(d, 0o755); err != nil {
			return err
		}
	}

	mainPath := filepath.Join(targetDir, "cmd", name, "main.go")
	mainContent := fmt.Sprintf(`package main

import "fmt"

func main() {
	fmt.Println("%s: hello from forge scaffold")
}
`, name)
	if err := os.WriteFile(mainPath, []byte(mainContent), 0o644); err != nil {
		return err
	}

	goModPath := filepath.Join(targetDir, "go.mod")
	goModContent := fmt.Sprintf("module %s\n\ngo 1.22\n", name)
	if err := os.WriteFile(goModPath, []byte(goModContent), 0o644); err != nil {
		return err
	}

	return nil
}

func initNodeProject(name, targetDir string, typescript bool) error {
	if targetDir != "." {
		if err := os.MkdirAll(filepath.Join(targetDir, "src"), 0o755); err != nil {
			return err
		}
	} else {
		if err := os.MkdirAll("src", 0o755); err != nil {
			return err
		}
	}

	baseDir := targetDir
	if baseDir == "." {
		baseDir = ""
	}

	ext := "js"
	if typescript {
		ext = "ts"
	}

	entryPath := filepath.Join(baseDir, "src", "index."+ext)
	entryContent := `console.log("` + name + `: hello from forge scaffold");` + "\n"
	if err := os.WriteFile(entryPath, []byte(entryContent), 0o644); err != nil {
		return err
	}

	pkgPath := filepath.Join(baseDir, "package.json")

	if typescript {
		pkgJSON := `{
  "name": "` + name + `",
  "version": "0.1.0",
  "scripts": {
    "start": "node dist/index.js",
    "build": "tsc"
  },
  "devDependencies": {
    "typescript": "^5.0.0"
  }
}
`
		if err := os.WriteFile(pkgPath, []byte(pkgJSON), 0o644); err != nil {
			return err
		}

		tsConfig := `{
  "compilerOptions": {
    "target": "ES2020",
    "module": "CommonJS",
    "outDir": "dist",
    "strict": true
  },
  "include": ["src"]
}
`
		if err := os.WriteFile(filepath.Join(baseDir, "tsconfig.json"), []byte(tsConfig), 0o644); err != nil {
			return err
		}
	} else {
		pkgJSON := `{
  "name": "` + name + `",
  "version": "0.1.0",
  "scripts": {
    "start": "node src/index.js"
  }
}
`
		if err := os.WriteFile(pkgPath, []byte(pkgJSON), 0o644); err != nil {
			return err
		}
	}

	return nil
}

func initEmptyProject(name, targetDir string) error {
	if targetDir != "." {
		if err := os.MkdirAll(targetDir, 0o755); err != nil {
			return err
		}
	}

	baseDir := targetDir
	if baseDir == "." {
		baseDir = ""
	}

	readme := filepath.Join(baseDir, "README.md")
	content := "# " + name + "\n\nEmpty project generated by forge.\n"
	if err := os.WriteFile(readme, []byte(content), 0o644); err != nil {
		return err
	}

	return nil
}
